# 内容分发平台 + 编辑器

## 目标

构建一个带有 Windows 客户端的 Web 服务，用于管理仅限于视频游戏的内容分发平台。

在此基础上添加一个多人游戏，包括服务器和相应的游戏。

## 交付内容

一个用于在线存储和管理游戏的 Web 服务。

一个 Windows 软件，用于浏览游戏、下载游戏并玩游戏。

一个游戏服务器，用于编排至少一个游戏的运行。

一个允许玩游戏的应用程序。

# 约束条件

允许的语言：C#、HTML、Javascript、CSS、TypeScript

Web 服务器：ASP.Net Core

Windows 软件：WPF

游戏服务器：C#

游戏：C# 配合 Godot、Unity、Winform、WPF、MAUI 等

## 起始项目

你的解决方案应该基于 Library.sln 项目。

服务器部分在 Gauniv.WebServer 项目中。

客户端部分在 Gauniv.Client 项目中。

客户端和服务器之间的连接在 Gauniv.Network 项目中。

你需要为游戏服务器和游戏本身创建两个项目。

游戏服务器应命名为 Gauniv.GameServer。

游戏应命名为 Gauniv.Game。

# 帮助文档

## 数据库

有关 Entity Framework 工作原理的信息：<https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=vs>

## MAUI – 手势

对于不支持 click 事件的元素

```xml
<Button Clicked="" />
```

你可以使用手势（Gesture）

```xml
<Label>
    <Label.GestureRecognizers>
        <TapGestureRecognizer Command="{Binding AppearingCommand}">
    </Label.Behaviors>
</Label>
```

## MAUI – 事件

如果你需要将事件从 View 传递到 ModelView，可以使用 CommunityToolkit 库提供的标签

示例：

```xml
<Label Focused="xxx">
```

添加此命名空间：

```xml
<xxx 
    xmlns:toolkit=http://schemas.microsoft.com/dotnet/2022/maui/toolkit>
</xxx>
```

然后你可以使用以下标签：
```xml
<Label>
    <Label.Behaviors>
        <toolkit:EventToCommandBehavior EventName="Focused"
            Command="{Binding FocusedCommand}"
            x:TypeArguments="FocusedEventArgs" />
    </Label.Behaviors>
</Label>
```

## DTO

要返回与数据库中存储的对象不同的对象，请使用 DTO
 - 手动创建 DTO：https://learn.microsoft.com/en-us/aspnet/web-api/overview/data/using-web-api-with-entity-framework/part-5
 - 使用 AutoMapper 库：https://automapper.org/

## Entity Framework

如果在读取存储在数据库中的对象的关联时获得 null 对象
例如：`appDbContext.Games.Categories.Where() => Categories is null`

要让 Entity Framework 返回带有游戏的类别：
 - 使用 Include 方法：`appDbContext.Games.Include(b => b.Categories).Where(x => x.Price > 0)`
 - 使用延迟加载（LazyLoading）
            https://learn.microsoft.com/en-us/ef/ef6/querying/related-data


## 开发建议

最初单独测试不同的软件可能会更容易：

- 向数据库注入测试数据。
- 在从客户端发出 HTTP 请求之前，使用静态数据创建你的界面。
- 不要加载真正的二进制文件，而是使用用默认编辑器打开的文本文件。

# 项目里程碑（3 天 MVP）

> **注意**：本规划聚焦于实现项目的核心必须功能，确保在 3 天内交付可运行的最小可行产品。

## Day 1：基础架构 + Web 服务器核心（8-10 小时）

**目标**：搭建项目基础，实现 Web 服务器和 API 的核心功能

### 上午（4-5 小时）
- [ ] 配置 Library.sln 解决方案和项目结构
- [ ] 创建数据模型（Game、User、Category 实体）
- [ ] 配置 Entity Framework 和数据库
- [ ] 创建数据库迁移和种子数据（5-10 个测试游戏）
- [ ] 实现简单的用户认证（基础 JWT）

### 下午（4-5 小时）
- [ ] 实现核心 REST API
  - [ ] `POST /api/auth/login` - 用户登录
  - [ ] `GET /api/games` - 获取游戏列表（支持基础分页）
  - [ ] `GET /api/games/{id}` - 获取游戏详情
  - [ ] `GET /api/categories` - 获取类别列表
  - [ ] `POST /api/games/{id}/purchase` - 购买游戏
  - [ ] `GET /api/games/{id}/download` - 下载游戏（简化版，小文件）
- [ ] 简单的管理界面（可选，或用 Swagger 替代）
- [ ] 测试所有 API 端点

**交付成果**：可运行的 Web 服务器 + 可用的 REST API

---

## Day 2：WPF 客户端 + 游戏服务器（8-10 小时）

**目标**：实现 Windows 客户端基础功能和游戏服务器

### 上午（4-5 小时）- WPF 客户端
- [ ] 创建 WPF 基础架构（MVVM 模式）
- [ ] 实现登录界面
- [ ] 实现游戏列表界面
  - [ ] 显示游戏名称、价格、类别
  - [ ] 简单的分页（上一页/下一页按钮）
  - [ ] 基础筛选（按类别）
- [ ] 实现游戏详情页面
  - [ ] 显示游戏信息
  - [ ] 购买按钮（如果未拥有）
  - [ ] 下载按钮（如果已购买但未下载）
  - [ ] 启动按钮（如果已下载）
- [ ] 实现游戏下载和启动逻辑（使用文本文件模拟游戏）

### 下午（4-5 小时）- 游戏服务器
- [ ] 创建 Gauniv.GameServer 控制台项目
- [ ] 实现 TCP 服务器基础框架
- [ ] 实现玩家连接和简单认证
- [ ] **实现多房间管理（必须）**
  - [ ] 支持至少 4 个房间同时运行
  - [ ] 房间管理器（创建、加入、离开房间）
  - [ ] 每个房间维护独立的游戏状态
  - [ ] 房间列表广播
- [ ] **实现多人联机支持（必须）**
  - [ ] 每个房间支持 2-4 名玩家同时连接
  - [ ] 维护每个房间的玩家连接状态
- [ ] **实现观察者模式（必须）**
  - [ ] 区分玩家（Player）和旁观者（Observer）角色
  - [ ] 旁观者可以连接但不参与游戏
  - [ ] 向旁观者广播游戏状态但不接受其操作
- [ ] 实现核心游戏流程
  - [ ] 等待玩家准备（最少 2 人，不含旁观者）
  - [ ] 随机选择主持人
  - [ ] 主持人选择方格（广播给所有玩家和旁观者）
  - [ ] 接收玩家点击时间（旁观者不能点击）
  - [ ] 计算排名并广播结果（给玩家和旁观者）
- [ ] 使用 JSON 或 MessagePack 进行通信

**交付成果**：可用的 WPF 客户端 + 可运行的游戏服务器

---

## Day 3：游戏客户端 + 集成测试（8-10 小时）

**目标**：完成游戏客户端并进行系统集成测试

### 上午（4-5 小时）- 游戏客户端
- [ ] 创建 Gauniv.Game 项目（WinForms 或 WPF，简单快速）
- [ ] 实现连接到游戏服务器
- [ ] 实现玩家登录界面（输入用户名）
- [ ] **实现房间列表界面（必须）**
  - [ ] 显示所有可用房间（至少显示4个房间）
  - [ ] 显示房间状态（等待中/游戏中/已满）
  - [ ] 显示每个房间的玩家数量（如 2/4）
  - [ ] "加入房间"按钮
  - [ ] "创建新房间"按钮
  - [ ] 实时刷新房间列表
- [ ] **实现角色选择界面（必须）**
  - [ ] 选择"玩家（Player）"或"旁观者（Observer）"
- [ ] 实现准备界面（Ready 按钮，仅玩家）
- [ ] **实现多人联机显示（必须）**
  - [ ] 显示当前房间所有玩家列表
  - [ ] 显示当前房间所有旁观者列表
  - [ ] 实时更新在线状态
- [ ] 实现游戏主界面
  - [ ] 显示 3×3 或 5×5 棋盘（Button 网格）
  - [ ] 主持人模式：选择方格并确认
  - [ ] 玩家模式：等待显示目标方格，然后快速点击
  - [ ] **旁观者模式（必须）**：只能观看，不能点击方格
- [ ] 实现结果显示界面
  - [ ] 显示玩家排名列表
  - [ ] 旁观者也可以看到排名（但自己不在榜上）
  - [ ] "返回房间列表"按钮

### 下午（4-5 小时）- 集成测试和完善
- [ ] 完整流程测试
  - [ ] Web 服务器 → 客户端登录 → 浏览游戏 → 下载 → 启动游戏
  - [ ] 游戏服务器 → 多个游戏客户端 → 完整游戏流程
- [ ] 修复发现的 Bug
- [ ] 基础错误处理（网络断开、服务器不可用等）
- [ ] 简单的 UI 优化（至少让界面可用）
- [ ] 准备演示和文档

**交付成果**：完整可运行的系统（4 个组件全部可用）

---

## 核心必须功能清单

### ✅ Web 服务器（ASP.NET）
- [x] 用户认证（简单的 JWT）
- [x] 游戏列表 API（基础分页）
- [x] 游戏详情 API
- [x] 类别列表 API
- [x] 购买游戏 API
- [x] 下载游戏 API（简化版）
- [ ] ~~管理界面~~（可用 Swagger 代替）
- [ ] ~~复杂筛选~~（只实现按类别筛选）
- [ ] ~~大文件流式传输~~（使用小文件测试）

### ✅ WPF 客户端
- [x] 登录
- [x] 显示游戏列表（简单分页）
- [x] 显示游戏详情
- [x] 购买游戏
- [x] 下载游戏（保存到本地）
- [x] 启动游戏（打开 exe 或文本文件）
- [ ] ~~用户配置文件~~
- [ ] ~~复杂筛选~~
- [ ] ~~进度显示~~

### ✅ 游戏服务器（必须支持多人联机 + 多房间）
- [x] TCP 服务器
- [x] 玩家连接和认证
- [ ] **多人联机支持（每房间2-4人，必须）** ⚠️
- [ ] **多房间支持（至少4个房间同时运行，必须）** ⚠️
  - [ ] 同时管理4个独立的游戏房间
  - [ ] 玩家可以选择加入或创建房间
  - [ ] 每个房间独立运行游戏
  - [ ] 显示所有房间列表和状态
- [ ] **观察者模式支持（必须）** ⚠️
  - [ ] 区分玩家和旁观者角色
  - [ ] 向旁观者广播游戏状态
  - [ ] 防止旁观者参与游戏操作
- [x] 角色分配（主持人/玩家）
- [x] 游戏流程（准备 → 选择 → 点击 → 结果）
- [x] 时间记录和排名
- [ ] 实时玩家列表和旁观者列表
- [ ] ~~复杂验证~~

### ✅ 游戏客户端（必须支持多人联机、多房间和观察者）
- [x] 连接服务器
- [x] 登录和准备
- [ ] **房间选择界面（必须）** ⚠️
  - [ ] 显示所有可用房间列表
  - [ ] 显示每个房间的状态（等待中/游戏中/已满）
  - [ ] 显示每个房间的玩家数量
  - [ ] 可以加入已有房间
  - [ ] 可以创建新房间
- [ ] **角色选择：玩家 or 旁观者（必须）** ⚠️
- [ ] **显示当前房间的所有玩家和旁观者（必须）** ⚠️
- [x] 棋盘显示（3×3 或 5×5）
- [x] 主持人：选择方格
- [x] 玩家：快速点击
- [ ] **旁观者：只能观看（必须）** ⚠️
  - [ ] 看到所有玩家的操作
  - [ ] 看到实时排名
  - [ ] 不能点击方格
- [x] 显示结果（玩家和旁观者都能看到）
- [ ] ~~计时器~~
- [ ] ~~动画效果~~

---

## 简化策略（确保 3 天完成）

### 🎯 优先级 P0（必须实现）
- 基础数据模型（Game, User, Category）
- 核心 API（登录、列表、下载）
- 基础 WPF 界面（能用即可）
- 游戏服务器核心逻辑
- 游戏客户端基础功能
- **多房间支持（至少 4 个房间同时运行）** ⚠️
- **多人联机支持（每房间 2-4 名玩家同时游戏）** ⚠️
- **观察者模式（旁观者可以观看但不能参与）** ⚠️

### 🔧 优先级 P1（简化实现）
- 使用小文本文件代替真实游戏二进制
- 简单的 UI（不追求美观，只要功能可用）
- 基础分页（上一页/下一页，不做无限滚动）
- 单一筛选条件（只按类别）
- 最小棋盘（3×3）

### 🚫 优先级 P2（暂时跳过）
- 管理界面（用 Swagger 测试 API）
- 大文件流式传输
- 复杂的错误处理
- 统计页面
- 好友系统
- 多房间支持
- 美化 UI/UX
- 详细的文档

---

## 每日检查点

### Day 1 结束检查
- ✅ Web 服务器可以启动
- ✅ 可以通过 Swagger/Postman 调用所有 API
- ✅ 数据库有测试数据

### Day 2 结束检查
- ✅ WPF 客户端可以登录并显示游戏列表
- ✅ 可以模拟下载和启动游戏
- ✅ 游戏服务器可以接受连接
- ✅ **游戏服务器支持至少 4 个房间同时运行**
- ✅ **每个房间支持多个玩家同时连接（至少2人）**
- ✅ **游戏服务器支持旁观者连接**

### Day 3 结束检查
- ✅ 游戏客户端可以显示房间列表
- ✅ 游戏客户端可以创建和加入房间
- ✅ 游戏客户端可以完成完整游戏流程
- ✅ **可以同时运行 4 个独立的游戏房间**
- ✅ **每个房间至少2-3名玩家可以同时游戏**
- ✅ **至少1名旁观者可以观看游戏**
- ✅ 旁观者只能观看不能参与游戏
- ✅ 所有 4 个组件可以协同工作
- ✅ 准备好演示（演示多房间+多人游戏+观察者模式）

# 预期功能

## 交付内容

- 一个包含以下内容的 Web 服务器： 
  - 管理界面
  - REST API
- 一个允许以下功能的客户端应用： 
  - 浏览游戏
  - 下载游戏
  - 启动游戏
- 一个独立的游戏服务器
- 一个游戏

# 内容分发平台（ASP.NET）

## 数据模型

存储一组游戏，包括：
 - 可访问游戏列表
 - 已购买游戏列表
 - 用于描述游戏的类型列表

其中：

- 一个游戏至少包含：
  - ID
  - 名称
  - 描述
  - 有效载荷（游戏二进制文件）
  - 价格
  - 类别（一个游戏可以有多个类别）

- 一个用户至少包含：
  - ID
  - 姓氏
  - 名字
  - 已购买游戏列表

## 管理功能

管理员必须能够：
 - 添加游戏
 - 删除游戏
 - 修改游戏
 - 添加新类别
 - 修改类别
 - 删除类别

用户必须能够：
 - 查看拥有的游戏列表
 - 购买新游戏
 - 查看拥有的游戏
 - 实时查看其他注册玩家的列表及其状态

所有人都可以：
 - 查看所有游戏列表
   - 按名称/价格/类别/拥有/大小筛选
 - 查看所有类别列表

### 可选功能

- 在游戏列表中显示筛选器，按类别/价格/拥有筛选。
- 显示统计信息的页面：
  - 可用游戏总数
  - 每个类别的游戏数量
  - 每个账户平均玩过的游戏数量
  - 每个游戏的平均游玩时间
  - 平台上和每个游戏的最大同时在线玩家数
- 由于游戏可能有几个 GB，需要将它们存储在经典数据库以外的地方。找到并实施一种机制来将游戏存储在数据库之外。
- 按照相同的原则，不要在发送之前将整个文件存储在内存中。直接流式传输二进制文件以减少服务器的内存占用。

不要显示所有玩家的列表，而是让每个玩家都有一个好友列表。

## API

必须提供 REST API，允许外部客户端查询库。

此 API 必须允许：

- 身份验证
- 检索游戏的二进制文件并在本地复制（注意：游戏可能有几个 GB，不可能将整个二进制文件存储在内存中）
- 列出可用类别（所有人）
- 列出游戏（包括筛选和分页）（所有人）
  - `/game`
  - `/game?offset=10&limit=15`
  - `/game?category=3`
  - `/game?category[]=3&category[]=4`
  - `/game?offset=10&limit=15&category[]=3`
  - `/game?offset=10&limit=15&category[]=3&category[]=2`
- 列出拥有的游戏（包括筛选和分页）（仅限已登录玩家）
  - `/game`
  - `/game?offset=10&limit=15`
  - `/game?category=3`
  - `/game?category[]=3&category[]=4`
  - `/game?offset=10&limit=15&category[]=3`
  - `/game?offset=10&limit=15&category[]=3&category[]=2`

游戏列表和我的游戏列表可以合并为一个 API。


# 应用程序（WPF、MAUI、WINUI）

应用程序必须能够：

- 列出游戏（你可以根据需要定义限制）
  - 包括分页（无限滚动、按钮或其他）
  - 按拥有的游戏/类别/价格等筛选
- 列出玩家拥有的游戏（你可以根据需要定义限制）
  - 包括分页（无限滚动、按钮或其他）
  - 按拥有的游戏/类别/价格等筛选
- 显示游戏详情（名称、描述、状态、类别）
- 下载、删除和启动游戏
  - 如果游戏尚未下载，用户不应看到"玩"和"删除"按钮
  - 同样，如果游戏已经可用，"下载"按钮将不可见
- 玩游戏
  - 查看游戏状态（未下载、就绪、游戏中等）
  - 控制游戏（启动、强制停止等）
- 查看和更新应用程序配置文件（安装文件夹、凭据等）

所有游戏相关数据必须来自服务器。


## 可选功能

- 显示带有格式的描述：字体样式、颜色、文本大小等
  - 考虑 RTF、HTML、PDF 等
  - 首先只管理一种格式。如果你完成了，可以同时管理多种格式
- 使用 [System.Speech.SpeechSynthesizer](https://learn.microsoft.com/en-us/dotnet/api/system.speech.synthesis.speechsynthesizer?view=net-9.0) API 朗读描述
  - 管理播放/停止/暂停/恢复
  - 根据播放状态更改控制按钮（如视频播放器，例如：YouTube）
  - 从用户选择的位置开始朗读。用户应该能够右键单击某个单词并从该单词开始播放


# 游戏服务器（控制台）

服务器是一个协调所有玩家的控制台应用程序。

玩家和服务器之间的通信通过 TCP 进行。

为了简化通信，我建议使用 MessagePack 或其他（Protobuff、Thrift、Cap'n Proto 等）。


## 游戏流程（多人联机 + 观察者模式）

游戏在 N*N 的棋盘上进行。**必须支持 2-4 名玩家同时游戏，以及若干旁观者观看。**

### 连接阶段
1. 玩家和旁观者连接到游戏服务器
2. 每个客户端选择角色：**玩家（Player）** 或 **旁观者（Observer）**
3. 服务器维护两个列表：
   - 玩家列表（参与游戏）
   - 旁观者列表（只能观看）
4. 向所有连接的客户端广播当前房间状态（玩家数量、旁观者数量）

### 游戏开始阶段
1. 服务器等待**所有玩家**准备好开始游戏（至少 2 名玩家，不含旁观者）
2. 服务器决定主持人（MJ）并通知所有参与者（包括旁观者）他们的角色
   - 主持人：从玩家中随机选择
   - 其他玩家：普通玩家
   - 旁观者：继续保持旁观者身份，**不参与游戏**

### 游戏进行阶段
3. 主持人决定一个方格并验证其选择
4. 服务器将主持人的选择广播给：
   - **所有玩家**（需要点击）
   - **所有旁观者**（只能观看）
5. 玩家收到开始信号并尽快点击主持人选择的方格
   - **旁观者不能点击方格**，只能观看
6. 服务器接收玩家的点击时间
7. 服务器根据每个玩家的反应时间确定玩家的最终顺序
8. 对于每个玩家，服务器验证玩家的参与是否有效

### 结果广播阶段
9. 服务器将最终结果传达给**所有人**（包括玩家和旁观者）：
   - 玩家排名
   - 每个玩家的反应时间
   - 旁观者可以看到结果，但不在排名中

## 玩家和旁观者

### 玩家（Player）
- 玩家必须通过登录名/密码向身份验证服务器进行身份验证。
  - 身份验证服务器必须返回一个证明身份验证的令牌（token）。
- 玩家由名称和身份验证令牌组成。
- 玩家可以：
  - 参与游戏
  - 点击方格
  - 获得排名

### 旁观者（Observer）⚠️ 必须实现
- 旁观者也需要通过身份验证连接到游戏服务器
- 旁观者由名称、身份验证令牌和**观察者标识**组成
- 旁观者可以：
  - 观看游戏实时进程
  - 看到所有玩家的操作
  - 看到游戏结果和排名
- 旁观者**不能**：
  - 参与游戏
  - 点击方格
  - 出现在排名中
  - 影响游戏进程

### 角色切换
- 玩家和旁观者的角色在**游戏开始前**确定
- 一旦游戏开始，角色不能更改
- 游戏结束后，可以重新选择角色进入下一局

## 可选功能

- 服务器知道如何同时管理多个游戏（因此它知道如何管理房间）。
- 将服务器部分与游戏部分分离：
  - 服务器是通用的并加载插件，每个插件都是一个游戏。
  - 服务器可以同时管理多个游戏。
  - 可以在不重新启动服务器的情况下添加游戏。
- 同时启动多个服务器以增加最大玩家容量：
  - 玩家可以连接到任何服务器并玩任何游戏。
  - 如果服务器一次只能管理一个游戏，那么所有服务器的所有玩家同时加入同一个游戏。
  - 如果服务器可以同时管理多个游戏，那么玩家可以选择要加入的游戏，无论其原始服务器是什么。


# 游戏（Godot、UNITY、Winform、Console 等）

## ⚠️ 必须功能

游戏**必须**支持以下功能：

### 1. 多人联机（必须）✅
- 至少支持 **2-4 名玩家**同时在线游戏
- 所有玩家通过游戏服务器连接和同步
- 实时显示其他玩家的状态和操作

### 2. 观察者模式（必须）✅
- 支持**旁观者（Observer）**角色
- 旁观者可以观看游戏进程，但不能参与游戏
- 旁观者可以实时看到：
  - 所有玩家的操作
  - 游戏当前状态
  - 实时排名和分数
- 旁观者数量不限（至少支持 1-2 名旁观者）

## 游戏用户界面

游戏必须实现允许玩家和旁观者使用的用户界面

### 通用功能（所有角色）

1. 输入连接凭据
2. 选择名称
3. **选择角色**：玩家（Player）或 旁观者（Observer）
4. 准备检查（仅玩家）

### 主持人角色

1. 等待其他玩家（显示玩家列表和旁观者列表）
2. 选择一个方格
3. 验证所选方格或更改
4. 查看所有玩家和旁观者的状态

### 玩家角色

1. 等待主持人的选择
2. 显示主持人选择的方格
3. 尽快点击目标方格
4. 查看自己的排名和反应时间
5. 显示结果

### 旁观者角色（Observer）✨

1. 连接到游戏房间
2. 实时观看游戏进程
3. 查看所有玩家的操作和状态
4. 查看实时排名和计时
5. **不能**参与游戏、不能点击方格
6. 可以随时退出观战

## 可选功能

- 添加点击的最大时间限制
- 管理好友列表中的玩家及其相应状态
- 用主持人创建的地图替换棋盘
- 旁观者可以发送文字聊天（但不影响游戏）
- 显示玩家的历史战绩
